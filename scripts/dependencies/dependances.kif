//We display the nodes in an indented way
function Display(synode x, int i) {
    if (x==null)
        return;
    string sp;
    sp.fill(i," ");
    println(sp,x);
    Display(x.child(),i+5);
    if (i) //when i==0, then it is the root of our tree, we do not want to display its sisters
        Display(x.next(),i);
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------
//we prepare our consituent tree
synode np1={"bar":2};
synode np2({"bar":2});
synode vp({"bar":2});
synode s({"bar":3});

synode v({"word":"eats","pers":3,"pres":"+","verb":"+"});
synode d1({"word":"the","det":"+"});
synode n1({"word":"dog","noun":"+"});
synode d2({"word":"a","det":"+"});
synode n2({"word":"bone","noun":"+"});


s.addchild(np1);
s.addchild(vp);

vp.addchild(v,np2);

np1.addchild(d1,n1);
np2.addchild(d2,n2);

//It is actually possible to add or modifiy existing features, as if a synode was a map
vp["pos"]="verb";
np1["pos"]="noun";
np2["pos"]="noun";
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Our initial dependencies...

D_ROOT(s).
D_ROOT(vp).
subj[val=1](v,n1).
obj[val=1](v,n2).
det(n1,d1).
det(n2,d2).
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------
//this function is called from a rule below. The #x becomes a synode.
//The function returns true, to avoid the rule to fail.
function DTree(synode n) {
    Display(n,0);
    println("---------------------------");
    return(true);
}
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------

If (^D_ROOT(#1)  and _(#2,#3) and !) D_ROOT[ajoute=+](#1).


If (^_1[val:1](#1,#2)) _1[truc=3,modif=1](#1,#2).

If (^_1[val:1](#1,#2)) _1[truc=~](#1,#2).

//We add features to a dependency
If (^subj[val:1](#1,#2)) subj[direct=+](#1,#2).

//A simple rule that inverts the nodes
If (subj(#1,#2)) inverted(#2,#1).


//A rule that uses constraints on nodes.
If (subj(#1[pres,pers:3],#2) and obj(#1,#3)) arguments(#2,#1,#3).

//We use _ to browse among all dependencies with two arguments, wich a constraint that two nodes are different
If (_(#1,#2) && obj(#1,#3) && #2 != #3) link(#2,#3).

//We use dependency variables _1, and _2 to avoid creating a dependency between the same arguments.
If (_1(#1,#2) && obj_2(#1,#3) && _1!=_2) other(#2,#3).

//we mark a node through a dependency rule, we can use some constraints into the structure as well
If (subj(#1,#2) and obj(#1,#3) and #2[noun:+, subject=+]) ~.

//We can also write this rule, note that you need to use quotes in this case:
If (subj(#1,#_) and obj(#1,#3) and #3["object"]="+") ~.

//In thie case, we access the parent of the node #1, note that parent is a synode method,
//which is available as a p_parent predicate (as for most Athanor objects).
//We then call DTree to display it... DTree must return true, otherwise the rule will fail.
//The #3 is automaticaly transformed into a synode object when the function is called...
If (det(#1,#2) and p_parent(#1,#3) and DTree(#3)) ~.

//we use here a ARE as constraint in our rule
If (obj(#1[word -: "e%a+"],#2)) Verb(#1).


//----------------------------------------------------------------------------------------------------------------------------------------------------------------------

//we launch our dependency parser...
_dependencies();

//we gather all the dependencies in the knowledge base.
vector res=predicatedump();

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Display(s,0);
println("---------------------------");
printjln(res);
























